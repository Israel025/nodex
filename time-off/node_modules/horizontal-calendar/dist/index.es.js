import React from 'react';

function ClassNames(rules) {
    var classes = '';

    Object.keys(rules).forEach(function (item) {
        if (rules[item]) classes += (classes.length ? ' ' : '') + item;
    });

    return classes;
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".scrollomatic-outer-container\n{\n    position: relative;\n    display: block;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n\n.scrollomatic-inner-container\n{\n    position: absolute;\n    display: block;\n    top: 0;\n    left: 0;\n    z-index: 1;\n    transition: left 0s ease-out, top 0s ease-out;\n}\n\n.scrollomatic-inner-container.slow-scroll\n{\n    transition-duration: 1s;\n}\n\n.scrollomatic-bottom-rail-light \n{\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 12px;\n    left: 0;\n    bottom: 0;\n    background-color: rgba(160,160,160,0.85);\n    transition: opacity 0.5s ease;    \n    z-index: 56;\n    cursor: ew-resize;\n}\n\n.scrollomatic-bottom-rail-dark\n{\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 12px;\n    left: 0;\n    bottom: 0;\n    background-color: rgba(80,80,80,0.85);\n    transition: opacity 0.5s ease;    \n    z-index: 55;\n    cursor: ew-resize;\n}\n\n.scrollomatic-bottom-thumb-light\n{\n    pointer-events: none;\n    position: absolute;\n    display: block;\n    top: 2px;\n    left: 30px;\n    height: 8px;\n    margin-left: 0;\n    border-radius: 5px;\n    background-color:rgba(0,0,0,0.4);\n    transition: background-color 0.5s ease;\n} \n\n.scrollomatic-bottom-thumb-dark\n{\n    pointer-events: none;\n    position: absolute;\n    display: block;\n    top: 2px;\n    left: 30px;\n    height: 8px;\n    margin-left: 0;\n    border-radius: 5px;\n    background-color:rgba(255,255,255,0.4);\n    transition: background-color 0.5s ease;\n} \n\n.scrollomatic-bottom-thumb-light.scrolling {\n    background-color: rgba(0,0,0,0.6);\n}\n\n.scrollomatic-bottom-thumb-dark.scrolling {\n    background-color: rgba(255,255,255,0.7);\n}\n\n.scrollomatic-side-rail-light\n{\n    position: absolute;\n    display: block;\n    top: 0;    \n    right: 0;\n    width: 12px;\n    height: 100%;\n    background-color: rgba(160,160,160,0.85);\n    transition: opacity 0.5s ease;    \n    z-index: 56;\n    cursor: ns-resize;    \n}\n\n.scrollomatic-side-rail-dark\n{\n    position: absolute;\n    display: block;\n    top: 0;    \n    right: 0;\n    width: 12px;\n    height: 100%;\n    background-color: rgba(80,80,80,0.85);\n    transition: opacity 0.5s ease;    \n    z-index: 55;\n    cursor: ns-resize;\n}\n\n.scrollomatic-side-thumb-light\n{\n    pointer-events: none;\n    position: absolute;\n    display: block;\n    top: 20px;\n    left: 2px;\n    width: 8px;\n    margin-left: 0;\n    border-radius: 5px;\n    background-color:rgba(0,0,0,0.4);\n    transition: background-color 0.5s ease;\n} \n\n.scrollomatic-side-thumb-dark\n{\n    pointer-events: none;\n    position: absolute;\n    display: block;\n    top: 20px;\n    left: 2px;\n    width: 8px;\n    margin-left: 0;\n    border-radius: 5px;\n    background-color:rgba(255,255,255,0.4);\n    transition: background-color 0.5s ease;\n} \n\n.scrollomatic-side-thumb-light.scrolling {\n    background-color: rgba(0,0,0,0.6);\n}\n\n.scrollomatic-side-thumb-dark.scrolling {\n    background-color: rgba(255,255,255,0.7);\n}\n";
styleInject(css);

/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @providesModule UserAgent_DEPRECATED
 */

/**
 *  Provides entirely client-side User Agent and OS detection. You should prefer
 *  the non-deprecated UserAgent module when possible, which exposes our
 *  authoritative server-side PHP-based detection to the client.
 *
 *  Usage is straightforward:
 *
 *    if (UserAgent_DEPRECATED.ie()) {
 *      //  IE
 *    }
 *
 *  You can also do version checks:
 *
 *    if (UserAgent_DEPRECATED.ie() >= 7) {
 *      //  IE7 or better
 *    }
 *
 *  The browser functions will return NaN if the browser does not match, so
 *  you can also do version compares the other way:
 *
 *    if (UserAgent_DEPRECATED.ie() < 7) {
 *      //  IE6 or worse
 *    }
 *
 *  Note that the version is a float and may include a minor version number,
 *  so you should always use range operators to perform comparisons, not
 *  strict equality.
 *
 *  **Note:** You should **strongly** prefer capability detection to browser
 *  version detection where it's reasonable:
 *
 *    http://www.quirksmode.org/js/support.html
 *
 *  Further, we have a large number of mature wrapper functions and classes
 *  which abstract away many browser irregularities. Check the documentation,
 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
 *  another copy of "event || window.event".
 *
 */

var _populated = false;

// Browsers
var _ie, _firefox, _opera, _webkit, _chrome;

// Actual IE browser for compatibility mode
var _ie_real_version;

// Platforms
var _osx, _windows, _linux, _android;

// Architectures
var _win64;

// Devices
var _iphone, _ipad, _native;

var _mobile;

function _populate() {
  if (_populated) {
    return;
  }

  _populated = true;

  // To work around buggy JS libraries that can't handle multi-digit
  // version numbers, Opera 10's user agent string claims it's Opera
  // 9, then later includes a Version/X.Y field:
  //
  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);

  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas);

  // Note that the IE team blog would have you believe you should be checking
  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
  // from either x64 or ia64;  so ultimately, you should just check for Win64
  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
  // Windows will send 'WOW64' instead.
  _win64 = !!(/Win64/.exec(uas));

  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : (
          agent[5] ? parseFloat(agent[5]) : NaN);
    // IE compatibility mode
    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    }
    // grab the "true" ie version from the trident token if available
    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;

    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;
    if (_webkit) {
      // We do not add the regexp to the above test, because it will always
      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
      // the userAgent string.
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }

  if (os) {
    if (os[1]) {
      // Detect OS X version.  If no version number matches, set _osx to true.
      // Version examples:  10, 10_6_1, 10.7
      // Parses version number as a float, taking only first two sets of
      // digits.  If only one set of digits is found, returns just the major
      // version number.
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);

      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
    } else {
      _osx = false;
    }
    _windows = !!os[2];
    _linux   = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}

var UserAgent_DEPRECATED = {

  /**
   *  Check if the UA is Internet Explorer.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  ie: function() {
    return _populate() || _ie;
  },

  /**
   * Check if we're in Internet Explorer compatibility mode.
   *
   * @return bool true if in compatibility mode, false if
   * not compatibility mode or not ie
   */
  ieCompatibilityMode: function() {
    return _populate() || (_ie_real_version > _ie);
  },


  /**
   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
   * this when we don't need it -- tracked by #601957.
   */
  ie64: function() {
    return UserAgent_DEPRECATED.ie() && _win64;
  },

  /**
   *  Check if the UA is Firefox.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  firefox: function() {
    return _populate() || _firefox;
  },


  /**
   *  Check if the UA is Opera.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  opera: function() {
    return _populate() || _opera;
  },


  /**
   *  Check if the UA is WebKit.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  webkit: function() {
    return _populate() || _webkit;
  },

  /**
   *  For Push
   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
   */
  safari: function() {
    return UserAgent_DEPRECATED.webkit();
  },

  /**
   *  Check if the UA is a Chrome browser.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  chrome : function() {
    return _populate() || _chrome;
  },


  /**
   *  Check if the user is running Windows.
   *
   *  @return bool `true' if the user's OS is Windows.
   */
  windows: function() {
    return _populate() || _windows;
  },


  /**
   *  Check if the user is running Mac OS X.
   *
   *  @return float|bool   Returns a float if a version number is detected,
   *                       otherwise true/false.
   */
  osx: function() {
    return _populate() || _osx;
  },

  /**
   * Check if the user is running Linux.
   *
   * @return bool `true' if the user's OS is some flavor of Linux.
   */
  linux: function() {
    return _populate() || _linux;
  },

  /**
   * Check if the user is running on an iPhone or iPod platform.
   *
   * @return bool `true' if the user is running some flavor of the
   *    iPhone OS.
   */
  iphone: function() {
    return _populate() || _iphone;
  },

  mobile: function() {
    return _populate() || (_iphone || _ipad || _android || _mobile);
  },

  nativeApp: function() {
    // webviews inside of the native apps
    return _populate() || _native;
  },

  android: function() {
    return _populate() || _android;
  },

  ipad: function() {
    return _populate() || _ipad;
  }
};

var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED;

/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

var ExecutionEnvironment_1 = ExecutionEnvironment;

var useHasFeature;
if (ExecutionEnvironment_1.canUseDOM) {
  useHasFeature =
    document.implementation &&
    document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment_1.canUseDOM ||
      capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

var isEventSupported_1 = isEventSupported;

// Reasonable defaults
var PIXEL_STEP  = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;

/**
 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
 * complicated, thus this doc is long and (hopefully) detailed enough to answer
 * your questions.
 *
 * If you need to react to the mouse wheel in a predictable way, this code is
 * like your bestest friend. * hugs *
 *
 * As of today, there are 4 DOM event types you can listen to:
 *
 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
 *
 * So what to do?  The is the best:
 *
 *   normalizeWheel.getEventType();
 *
 * In your event callback, use this code to get sane interpretation of the
 * deltas.  This code will return an object with properties:
 *
 *   spinX   -- normalized spin speed (use for zoom) - x plane
 *   spinY   -- " - y plane
 *   pixelX  -- normalized distance (to pixels) - x plane
 *   pixelY  -- " - y plane
 *
 * Wheel values are provided by the browser assuming you are using the wheel to
 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
 * significantly on different platforms and browsers, forgetting that you can
 * scroll at different speeds.  Some devices (like trackpads) emit more events
 * at smaller increments with fine granularity, and some emit massive jumps with
 * linear speed or acceleration.
 *
 * This code does its best to normalize the deltas for you:
 *
 *   - spin is trying to normalize how far the wheel was spun (or trackpad
 *     dragged).  This is super useful for zoom support where you want to
 *     throw away the chunky scroll steps on the PC and make those equal to
 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
 *     resolve a single slow step on a wheel to 1.
 *
 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
 *     get the crazy differences between browsers, but at least it'll be in
 *     pixels!
 *
 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
 *     should translate to positive value zooming IN, negative zooming OUT.
 *     This matches the newer 'wheel' event.
 *
 * Why are there spinX, spinY (or pixels)?
 *
 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
 *     with a mouse.  It results in side-scrolling in the browser by default.
 *
 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
 *
 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
 *     probably is by browsers in conjunction with fancy 3D controllers .. but
 *     you know.
 *
 * Implementation info:
 *
 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
 * average mouse:
 *
 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
 *
 * On the trackpad:
 *
 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
 *
 * On other/older browsers.. it's more complicated as there can be multiple and
 * also missing delta values.
 *
 * The 'wheel' event is more standard:
 *
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
 *
 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
 * backward compatibility with older events.  Those other values help us
 * better normalize spin speed.  Example of what the browsers provide:
 *
 *                          | event.wheelDelta | event.detail
 *        ------------------+------------------+--------------
 *          Safari v5/OS X  |       -120       |       0
 *          Safari v5/Win7  |       -120       |       0
 *         Chrome v17/OS X  |       -120       |       0
 *         Chrome v17/Win7  |       -120       |       0
 *                IE9/Win7  |       -120       |   undefined
 *         Firefox v4/OS X  |     undefined    |       1
 *         Firefox v4/Win7  |     undefined    |       3
 *
 */
function normalizeWheel(/*object*/ event) /*object*/ {
  var sX = 0, sY = 0,       // spinX, spinY
      pX = 0, pY = 0;       // pixelX, pixelY

  // Legacy
  if ('detail'      in event) { sY = event.detail; }
  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

  // side scrolling on FF with DOMMouseScroll
  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in event) { pY = event.deltaY; }
  if ('deltaX' in event) { pX = event.deltaX; }

  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {          // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {                             // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

  return { spinX  : sX,
           spinY  : sY,
           pixelX : pX,
           pixelY : pY };
}


/**
 * The best combination if you prefer spinX + spinY normalization.  It favors
 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
 * 'wheel' event, making spin speed determination impossible.
 */
normalizeWheel.getEventType = function() /*string*/ {
  return (UserAgent_DEPRECATED_1.firefox())
           ? 'DOMMouseScroll'
           : (isEventSupported_1('wheel'))
               ? 'wheel'
               : 'mousewheel';
};

var normalizeWheel_1 = normalizeWheel;

var normalizeWheel$1 = normalizeWheel_1;

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var idCounter = 1;

var BottomScroller = function (_React$Component) {
    inherits(BottomScroller, _React$Component);

    function BottomScroller(props) {
        classCallCheck(this, BottomScroller);

        var _this = possibleConstructorReturn(this, (BottomScroller.__proto__ || Object.getPrototypeOf(BottomScroller)).call(this, props));

        _this.calculate = function () {
            var showingRatio = _this.props.windowSize / _this.props.scrollSize;
            _this.thumbSize = _this.props.windowSize * showingRatio;
        };

        _this.onOnePage = function (ev) {
            var onePage = _this.props.windowSize * 0.5;

            var ratio = _this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize);
            // get actual postion in scroll range and add the normalized pixel change
            // we increment (by delta) the number of pixels of scroll, not the scroll bar position which is choppy
            // and doesn't scale on really long lists
            var actualPosition = ratio * (_this.props.scrollSize - _this.props.windowSize) + (_this.state.inBox == 'left' ? -1 * onePage : onePage);

            var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

            if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: newPosition,
                clickScroll: true
            });
            _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize), true);

            ev.preventDefault();
            ev.stopPropagation();
        };

        _this.scrollTo = function (position, scrollEffect) {

            scrollEffect = scrollEffect === true;
            var actualPosition = position;

            var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

            if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: newPosition,
                clickScroll: true
            });
            _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize), scrollEffect);
        };

        _this.onMouseDown = function (ev) {

            var railBounds = _this.railRef.current.getBoundingClientRect();

            if (_this.state.inBox !== true) {
                _this.onOnePage(ev);
                return;
            }

            _this.setState({
                mouseDown: true,
                clickScroll: false
            });

            _this.startPosition = _this.state.thumbPosition - (ev.clientX - railBounds.left); //- this.thumbRef.current.getBoundingClientRect().left - railBounds.left

            document.addEventListener('mouseup', _this.onMouseUp, true);
            document.addEventListener('mousemove', _this.onMouseMove, true);
            ev.preventDefault();
            ev.stopPropagation();

            document.body.style['pointer-events'] = 'none';
        };

        _this.setPosition = function (ev) {
            var railBounds = _this.railRef.current.getBoundingClientRect();

            var thumbPosition = ev.clientX - railBounds.left + _this.startPosition;

            if (thumbPosition < 0) thumbPosition = 0;else if (thumbPosition + _this.thumbSize > _this.props.windowSize) thumbPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: thumbPosition
            });
        };

        _this.onTarget = function (ev) {
            var railBounds = _this.railRef.current.getBoundingClientRect();
            var left = ev.clientX - railBounds.left;

            _this.setState({
                inBox: left >= _this.state.thumbPosition && left <= _this.state.thumbPosition + _this.thumbSize ? true : left < _this.state.thumbPosition ? 'left' : 'right'
            });
        };

        _this.onMouseUp = function (ev) {

            if (_this.state.mouseDown) {
                _this.setState({
                    mouseDown: false
                });
            }

            if (_this.state.clickScroll) {
                _this.setState({
                    clickScroll: false
                });

                ev.stopPropagation();
                ev.preventDefault();
                return;
            }

            var railBounds = _this.railRef.current.getBoundingClientRect();

            if (ev.clientX >= railBounds.left && ev.clientX <= railBounds.right && ev.clientY >= railBounds.top && ev.clientY <= railBounds.bottom) ; else {
                _this.setState({
                    showing: false
                });
            }

            document.removeEventListener('mouseup', _this.onMouseUp, true);
            document.removeEventListener('mousemove', _this.onMouseMove, true);
            ev.stopPropagation();
            ev.preventDefault();

            document.body.style['pointer-events'] = 'auto';
        };

        _this.onMouseMove = function (ev) {

            ev.stopPropagation();
            ev.preventDefault();

            _this.onTarget(ev);

            if (!_this.state.mouseDown) return false;

            _this.setPosition(ev);

            if (_this.props.onPan) _this.props.onPan(_this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize));

            return true;
        };

        _this.onMouseEnter = function (ev) {
            _this.setState({
                showing: true
            });
        };

        _this.onMouseLeave = function (ev) {
            if (!_this.state.mouseDown) _this.setState({
                showing: false
            });
        };

        _this.onWheel = function (ev) {

            // call fancy facebook function that un-messes all the browser variations with
            // wheel scroll deltas (thank you FB)
            var normalized = normalizeWheel$1(ev);

            if (!_this.inWheel) {
                _this.inWheel = true;
            }

            if (normalized.pixelX) {

                // get the percentage along of scroll position to scroll area (width - with of thumb)
                var ratio = _this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize);
                // get actual postion in scroll range and add the normalized pixel change
                // we increment (by delta) the number of pixels of scroll, not the scroll bar position which is choppy
                // and doesn't scale on really long lists
                var actualPosition = ratio * (_this.props.scrollSize - _this.props.windowSize) + normalized.pixelX;

                // convert this back to scroll pixels..
                var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

                if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

                _this.setState({
                    thumbPosition: newPosition,
                    showing: normalized.pixelX ? true : false
                });
                _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize));
            }

            if (_this.scrollHideTo) clearTimeout(_this.scrollHideTo);

            _this.scrollHideTo = setTimeout(function () {
                _this.scrollHideTo = null;
                _this.setState({
                    showing: false,
                    mouseDown: false,
                    inBox: false
                });
                _this.inWheel = false;
            }, 500);

            ev.preventDefault();
        };

        _this.state = {
            thumbPosition: 0,
            startPosition: 0,
            id: ++idCounter + '_h_scroller',
            clickStarted: false
        };

        _this.railRef = React.createRef();
        _this.thumbRef = React.createRef();
        return _this;
    }

    createClass(BottomScroller, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.calculate();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            this.calculate();
        }
    }, {
        key: 'render',
        value: function render() {

            var thumbClass = this.props.dark ? 'scrollomatic-bottom-thumb-dark' : 'scrollomatic-bottom-thumb-light';

            if (this.state.mouseDown || this.state.inBox === true) thumbClass += ' scrolling';

            return React.createElement(
                'div',
                {
                    id: this.state.id,
                    ref: this.railRef,
                    className: this.props.dark ? 'scrollomatic-bottom-rail-dark' : 'scrollomatic-bottom-rail-light',
                    onMouseDown: this.onMouseDown,
                    onMouseEnter: this.onMouseEnter,
                    onMouseLeave: this.onMouseLeave,
                    onMouseMove: this.onMouseMove,
                    onWheel: this.onWheel,
                    style: {
                        width: this.props.windowSize,
                        opacity: this.state.showing ? 1 : 0.001
                    }
                },
                React.createElement('div', {
                    ref: this.thumbRef,
                    className: thumbClass,
                    style: {
                        left: this.state.thumbPosition,
                        width: this.thumbSize
                    } })
            );
        }
    }]);
    return BottomScroller;
}(React.Component);

var idCounter$1 = 1;

var SideScroller = function (_React$Component) {
    inherits(SideScroller, _React$Component);

    function SideScroller(props) {
        classCallCheck(this, SideScroller);

        var _this = possibleConstructorReturn(this, (SideScroller.__proto__ || Object.getPrototypeOf(SideScroller)).call(this, props));

        _this.calculate = function () {

            var scrollSize = _this.props.windowSize < _this.props.scrollSize ? _this.props.scrollSize : _this.props.windowSize;

            var showingRatio = _this.props.windowSize / scrollSize;
            _this.thumbSize = _this.props.windowSize * showingRatio;
        };

        _this.onOnePage = function (ev) {

            var onePage = _this.props.windowSize * 0.5;

            var ratio = _this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize);
            // get actual postion in scroll range and add the normalized pixel change
            // we increment (by delta) the number of pixels of scroll, not the scroll bar position which is choppy
            // and doesn't scale on really long lists
            var actualPosition = ratio * (_this.props.scrollSize - _this.props.windowSize) + (_this.state.inBox == 'left' ? -1 * onePage : onePage);

            var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

            if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: newPosition,
                clickScroll: true
            });
            _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize), true);

            ev.preventDefault();
            ev.stopPropagation();
        };

        _this.scrollTo = function (position, scrollEffect) {

            scrollEffect = scrollEffect === true;
            var actualPosition = position;

            var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

            if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: newPosition,
                clickScroll: true
            });
            _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize), scrollEffect);
        };

        _this.onMouseDown = function (ev) {

            var railBounds = _this.railRef.current.getBoundingClientRect();

            if (_this.state.inBox !== true) {
                _this.onOnePage(ev);
                return;
            }

            _this.setState({
                mouseDown: true,
                clickScroll: false
            });

            _this.startPosition = _this.state.thumbPosition - (ev.clientY - railBounds.top); //- this.thumbRef.current.getBoundingClientRect().left - railBounds.left

            document.addEventListener('mouseup', _this.onMouseUp, true);
            document.addEventListener('mousemove', _this.onMouseMove, true);
            ev.preventDefault();
            ev.stopPropagation();

            document.body.style['pointer-events'] = 'none';
        };

        _this.setPosition = function (ev) {
            var railBounds = _this.railRef.current.getBoundingClientRect();

            var thumbPosition = ev.clientY - railBounds.top + _this.startPosition;

            if (thumbPosition < 0) thumbPosition = 0;else if (thumbPosition + _this.thumbSize > _this.props.windowSize) thumbPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: thumbPosition
            });
        };

        _this.onTarget = function (ev) {
            var railBounds = _this.railRef.current.getBoundingClientRect();
            var left = ev.clientY - railBounds.top;

            _this.setState({
                inBox: left >= _this.state.thumbPosition && left <= _this.state.thumbPosition + _this.thumbSize ? true : left < _this.state.thumbPosition ? 'left' : 'right'
            });
        };

        _this.onMouseUp = function (ev) {

            if (_this.state.mouseDown) {
                _this.setState({
                    mouseDown: false
                });
            }

            if (_this.state.clickScroll) {
                _this.setState({
                    clickScroll: false
                });

                ev.stopPropagation();
                ev.preventDefault();
                return;
            }

            var railBounds = _this.railRef.current.getBoundingClientRect();

            if (ev.clientX >= railBounds.left && ev.clientX <= railBounds.right && ev.clientY >= railBounds.top && ev.clientY <= railBounds.bottom) ; else {
                _this.setState({
                    showing: false
                });
            }

            document.removeEventListener('mouseup', _this.onMouseUp, true);
            document.removeEventListener('mousemove', _this.onMouseMove, true);
            ev.stopPropagation();
            ev.preventDefault();

            document.body.style['pointer-events'] = 'auto';
        };

        _this.onMouseMove = function (ev) {

            ev.stopPropagation();
            ev.preventDefault();

            _this.onTarget(ev);

            if (!_this.state.mouseDown) return false;

            _this.setPosition(ev);

            if (_this.props.onPan) _this.props.onPan(_this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize));

            return true;
        };

        _this.onMouseEnter = function (ev) {
            _this.setState({
                showing: true
            });
        };

        _this.onMouseLeave = function (ev) {
            if (!_this.state.mouseDown) _this.setState({
                showing: false
            });
        };

        _this.onWheel = function (ev) {

            // call fancy facebook function that un-messes all the browser variations with
            // wheel scroll deltas (thank you FB)
            var normalized = normalizeWheel$1(ev);

            if (!_this.inWheel) {
                _this.inWheel = true;
            }

            if (normalized.pixelY) {

                // get the percentage along of scroll position to scroll area (width - with of thumb)
                var ratio = _this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize);
                // get actual postion in scroll range and add the normalized pixel change
                // we increment (by delta) the number of pixels of scroll, not the scroll bar position which is choppy
                // and doesn't scale on really long lists
                var actualPosition = ratio * (_this.props.scrollSize - _this.props.windowSize) + normalized.pixelY;

                // convert this back to scroll pixels..
                var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

                if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

                _this.setState({
                    thumbPosition: newPosition,
                    showing: normalized.pixelY ? true : false
                });
                _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize));
            }

            if (_this.scrollHideTo) clearTimeout(_this.scrollHideTo);

            _this.scrollHideTo = setTimeout(function () {
                _this.scrollHideTo = null;
                _this.setState({
                    showing: false,
                    mouseDown: false,
                    inBox: false
                });
                _this.inWheel = false;
            }, 500);

            ev.preventDefault();
        };

        _this.state = {
            thumbPosition: 0,
            startPosition: 0,
            id: ++idCounter$1 + '_v_scroller',
            clickStarted: false
        };

        _this.railRef = React.createRef();
        _this.thumbRef = React.createRef();
        return _this;
    }

    createClass(SideScroller, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.calculate();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            this.calculate();
        }
    }, {
        key: 'render',
        value: function render() {

            var thumbClass = this.props.dark ? 'scrollomatic-side-thumb-dark' : 'scrollomatic-side-thumb-light';

            if (this.state.mouseDown || this.state.inBox === true) thumbClass += ' scrolling';

            return React.createElement(
                'div',
                {
                    id: this.state.id,
                    ref: this.railRef,
                    className: this.props.dark ? 'scrollomatic-side-rail-dark' : 'scrollomatic-side-rail-light',
                    onMouseDown: this.onMouseDown,
                    onMouseEnter: this.onMouseEnter,
                    onMouseLeave: this.onMouseLeave,
                    onMouseMove: this.onMouseMove,
                    onWheel: this.onWheel,
                    style: {
                        height: this.props.windowSize,
                        opacity: this.state.showing ? 1 : 0.001
                    }
                },
                React.createElement('div', {
                    ref: this.thumbRef,
                    className: thumbClass,
                    style: {
                        top: this.state.thumbPosition,
                        height: this.thumbSize
                    } })
            );
        }
    }]);
    return SideScroller;
}(React.Component);

var Scrollomatic = function (_React$Component) {
    inherits(Scrollomatic, _React$Component);

    function Scrollomatic(props) {
        classCallCheck(this, Scrollomatic);

        var _this = possibleConstructorReturn(this, (Scrollomatic.__proto__ || Object.getPrototypeOf(Scrollomatic)).call(this, props));

        _this.getDims = function () {
            var bounds = _this.outerRef.current.getBoundingClientRect();

            var newState = {
                windowWidth: bounds.width,
                windowHeight: bounds.height,

                scrollWidth: _this.innerRef.current.scrollWidth,
                scrollHeight: _this.innerRef.current.scrollHeight
            };

            _this.setState(_extends({}, newState, {
                dims: true,
                showHorz: newState.scrollWidth > newState.windowWidth && !_this.props.noHorizontal ? true : false,
                showVert: newState.scrollHeight > newState.windowHeight && !_this.props.noVertical ? true : false
            }));
        };

        _this.onWheel = function (ev) {
            if (_this.state.showHorz) _this.horzRef.current.onWheel(ev);
            if (_this.state.showVert) _this.vertRef.current.onWheel(ev);

            ev.stopPropagation();
            if (ev.preventDefault) ev.preventDefault();
        };

        _this.onHScroll = function (ratio, isPage) {
            _this.setState({
                hpos: -1 * (ratio * (_this.state.scrollWidth - _this.state.windowWidth)),
                onePage: isPage
            });

            if (_this.unsetTo) clearTimeout(_this.unsetTo);

            if (isPage) {
                _this.unsetTo = setTimeout(function () {
                    _this.unsetTo = null;
                    _this.setState({
                        onePage: false
                    });
                }, 1100);
            }
        };

        _this.onVScroll = function (ratio, isPage) {
            _this.setState({
                vpos: -1 * (ratio * (_this.state.scrollHeight - _this.state.windowHeight)),
                onePage: isPage
            });

            if (_this.unsetTo) clearTimeout(_this.unsetTo);

            if (isPage) {

                _this.unsetTo = setTimeout(function () {
                    _this.unsetTo = null;
                    _this.setState({
                        onePage: false
                    });
                }, 1100);
            }
        };

        _this.pan = function (left, top) {
            if (left && _this.state.showHorz) _this.horzRef.current.scrollTo(left);
            if (top && _this.state.showVert) _this.vertRef.current.scrollTo(top);
        };

        _this.state = {
            vPos: 0,
            hPos: 0
        };

        _this.outerRef = React.createRef();
        _this.innerRef = React.createRef();

        _this.horzRef = React.createRef();
        _this.vertRef = React.createRef();

        _this.dimCheckInterval = null;
        return _this;
    }

    createClass(Scrollomatic, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.dimCheckInterval = setInterval(this.getDims, 100);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            clearInterval(this.dimCheckInterval);
        }
    }, {
        key: 'render',
        value: function render() {

            var innerClasses = 'scrollomatic-inner-container';

            if (this.state.onePage) innerClasses += ' slow-scroll';

            return React.createElement(
                'div',
                {
                    ref: this.outerRef,
                    style: _extends({}, this.props.style),
                    className: 'scrollomatic-outer-container' },
                React.createElement(
                    'div',
                    {
                        ref: this.innerRef,
                        className: innerClasses,
                        onWheel: this.onWheel,
                        style: {
                            left: this.state.hpos,
                            top: this.state.vpos
                        }
                    },
                    this.props.children
                ),
                this.state.showHorz && React.createElement(BottomScroller, {
                    ref: this.horzRef,
                    dark: this.props.dark,
                    scrollSize: this.state.scrollWidth,
                    windowSize: this.state.windowWidth,
                    corner: this.state.showHorz && this.state.showVert,
                    onPan: this.onHScroll }),
                this.state.showVert && React.createElement(SideScroller, {
                    ref: this.vertRef,
                    dark: this.props.dark,
                    scrollSize: this.state.scrollHeight,
                    windowSize: this.state.windowHeight,
                    corner: this.state.showHorz && this.state.showVert,
                    onPan: this.onVScroll })
            );
        }
    }]);
    return Scrollomatic;
}(React.Component);

function styleInject$1(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css$1 = ".vc-container {\n    position: relative;\n    display: block;\n    width: 100%;\n    height: 155px;\n}\n\n.vc-container-inner {\n    position: relative;\n    display: block;\n    background-color: #151515;\n}\n\n.vc-cell {\n    position: absolute;\n    display: flex;\n    background-color: #3e4f53;\n    color: rgba(255,255,255,0.75);\n    width: 22px;\n    height: 22px;\n    justify-content: center;\n    border-radius: 0px;\n    align-items: center;\n    font-size: 12px;\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    line-height: 22px;\n    user-select: none;\n\n}\n\n.vc-cell.lit {\n    background-color: rgb(64, 150, 184);\n    color: rgba(0,0,0,0.8);\n    margin-top: 0px;\n    cursor: pointer;\n}\n\n.vc-cell.lit.week {\n    padding-bottom: 3px;\n    border-bottom-left-radius: 5px !important;\n    border-bottom-right-radius: 5px !important;\n}\n\n\n.vc-cell.dim {\n    background-color: #151515;\n    margin-left: -11px;\n    color: rgba(255,255,255,0.80);\n}\n\n.vc-cell-stay-in-view {\n    position: sticky;\n    left: 0px;\n    margin-right: auto;\n    padding-right: 10px;\n    padding-left: 10px;\n    z-index: 10;\n    user-select: none;\n}\n\n.vc-cell.click {\n    cursor: pointer;\n    user-select: none;\n    transition: background-color 0.33s ease-in-out, color 0.33s ease-in-out;\n    transition-delay: 0.1s;\n\n}\n\n.vc-cell.click:hover {\n    background-color: goldenrod;\n    color: rgba(0,0,0,0.8);\n    z-index: 11;\n}\n\n.vc-cell.click:active {\n    background-color: white;\n    color: rgba(0,0,0,0.8);\n    transition-delay: 0s;\n    z-index: 11;\n}\n\n.vc-void {\n    position: absolute;\n    background: repeating-linear-gradient(\n        -55deg,\n        #00000010,\n        #00000010 3px,\n        #00000040 3px,\n        #00000440 6px\n      );\n      z-index: 5;\n}\n\n.vc-select {\n    position: absolute;\n    pointer-events: none;\n    background: #00a0ca2a;\n    border: solid 1px rgb(64, 150, 184);\n    border-radius: 2px;\n    z-index: 6;\n    transition: left 0.4s cubic-bezier(0.19, 1, 0.22, 1), width 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n}\n\n\n.vc-void.left {\n    border-left: solid 1px rgba(0,0,0,0.05);\n}\n\n.vc-void.right{\n    border-right: solid 1px rgba(0,0,0,0.05);\n}\n\n.vc-status-box {\n    position: fixed;\n    display: flex;\n    flex-direction: row;\n    left: 0px;\n    top: 0px;\n    height: 27px;\n    color: #eee;\n    font-size: 12px;\n    animation: shake 1.3s cubic-bezier(.36,.07,.19,.97) both;\n    z-index: 20;\n    justify-content: flex-end;\n    user-select: none;\n    pointer-events: none;\n}\n\n@keyframes shake {\n    10%, 90% {\n      transform: translate3d(-1px, 0, 0);\n    }\n    \n    20%, 80% {\n      transform: translate3d(4px, 0, 0);\n    }\n  \n    30%, 50%, 70% {\n      transform: translate3d(0px, 0, 0);\n    }\n  \n    40%, 60% {\n      transform: translate3d(4px, 0, 0);\n    }\n}\n\n.vc-range-button {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    justify-items: center;\n    align-content: center;\n    font-size: 14px;\n    color: rgba(0,0,0,0.75);\n    background-color: darkgoldenrod;\n    padding-left: 10px;\n    padding-right: 10px;\n    height: 27px;\n    margin-top: 3px;\n    margin-right: 3px;\n    border-radius: 6px;\n    cursor: pointer;\n    pointer-events: all;\n}\n\n.vc-range-button:hover {\n    color: darkgoldenrod;\n}\n\n.vc-range-button:active {\n    color: white;\n}\n";
styleInject$1(css$1);

var classCallCheck$1 = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass$1 = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var inherits$1 = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn$1 = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var dayFactor = 86400000;

var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

function stndth(number) {

    var test = number % 100;

    if (test == 11 || test == 12 || test == 13) {
        number += 'th';
    } else {

        test = number % 10;

        if (test == 1) number += 'st';else if (test == 2) number += 'nd';else if (test == 3) number += 'rd';else number += 'th';
    }
    return number;
}

var HorizontalCalendar = function (_React$Component) {
    inherits$1(HorizontalCalendar, _React$Component);

    function HorizontalCalendar(props) {
        classCallCheck$1(this, HorizontalCalendar);

        var _this = possibleConstructorReturn$1(this, (HorizontalCalendar.__proto__ || Object.getPrototypeOf(HorizontalCalendar)).call(this, props));

        _initialiseProps.call(_this);

        _this.state = {
            calculated: false,
            startDay: 0,
            originalStartIndex: 0,
            endDay: 1,
            span: 1,
            unitWidth: 22,
            unitHeight: 22,
            spacing: 1,
            selectedMode: 'none',
            selectedIndex: 0,
            selectedEndIndex: -1,
            noSelect: {}
        };

        _this.days = [];
        _this.weeks = [];
        _this.months = [];
        _this.quarters = [];
        _this.years = [];

        var startDay = _this.parseDate(_this.props.startDate);
        var endDay = _this.parseDate(_this.props.endDate);

        if (endDay < startDay) {

            var _ref = [startDay, endDay];
            endDay = _ref[0];
            startDay = _ref[1];
        }_this.state.startDay = startDay;
        _this.state.endDay = endDay;

        if (_this.props.selectedMode && _this.props.selectedDate) {
            _this.loadStartDate = _this.parseDate(_this.props.selectedDate);
            _this.loadStartMode = _this.props.selectedMode;
        }

        _this.scrollRef = React.createRef();
        return _this;
    }

    createClass$1(HorizontalCalendar, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            setImmediate(this.makeDates);
        }
    }, {
        key: 'render',
        value: function render() {

            var top = 1;
            var spacing = this.state.unitHeight + this.state.spacing;

            var yPos = top;

            var showing = this.props.showing || {
                years: true,
                quarters: true,
                months: true,
                days: true,
                weeks: true
            };

            var yearsY = yPos;
            if (showing.years) yPos += spacing;
            var quartersY = yPos;
            if (showing.quarters) yPos += spacing;
            var monthsY = yPos;
            if (showing.months) yPos += spacing;
            var daysY = yPos;
            if (showing.days) yPos += spacing;
            var weeksY = yPos;
            if (showing.weeks) yPos += 8;

            this.maskingHeight = yPos - top - (showing.weeks ? 0 : 3);

            return React.createElement(
                Scrollomatic,
                { ref: this.scrollRef, style: { height: this.maskingHeight + 18 } },
                React.createElement(
                    'div',
                    {
                        key: 'vc-inner',
                        className: 'vc-container-inner',
                        style: {
                            width: this.state.width,
                            height: this.maskingHeight + 18
                        } },
                    showing.years && this.makeYears(yearsY),
                    showing.quarters && this.makeQuarters(quartersY),
                    showing.months && this.makeMonths(monthsY),
                    showing.days && this.makeDays(daysY),
                    showing.weeks && this.makeWeeks(weeksY),
                    this.masking(),
                    this.showCurrent(),
                    this.status()
                )
            );
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(props, state) {
            return {
                noSelect: props.noSelect || state.noSelect
            };
        }
    }]);
    return HorizontalCalendar;
}(React.Component);

var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.parseDate = function (date) {

        if (!date || date === 'now') return Math.floor(new Date().getTime() / dayFactor);

        if (typeof date === 'string') {
            var _date$split$map = date.split('-').map(Number),
                _date$split$map2 = slicedToArray(_date$split$map, 3),
                year = _date$split$map2[0],
                month = _date$split$map2[1],
                day = _date$split$map2[2];

            return Math.floor(new Date(year, month - 1, day) / dayFactor);
        }

        return Math.floor(new Date(date).getTime() / dayFactor);
    };

    this.makeDates = function () {

        var isLeapYear = function isLeapYear(year) {
            return year % 400 === 0 || year % 100 !== 0 && year % 4 === 0;
        };

        var daysInYear = function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
        };

        // last being last pushed
        var lastYear = -1;
        var lastMonth = -1;
        var lastQuarter = -1;

        // ud = unixDay which is unixtime / 86400 milliseconds (86,400,000)
        var endDay = _this2.state.endDay; //Math.floor(new Date().getTime() / dayFactor)
        //let startDay = endDay - (365 * 5)      
        //const endDay = Math.floor(new Date().getTime() / dayFactor) + 60              
        var adjustedEndDay = endDay;
        var startDay = _this2.state.startDay;
        var originalStartIndex = startDay;
        var weekStartIndex = startDay;

        var fixDate = new Date(startDay * dayFactor);

        if (fixDate.getUTCDate() != 1) {

            startDay -= fixDate.getUTCDate() - 1;
            // we moved the calendar over, so... are we in a month that doesn't exist?
            var testMonth = fixDate.getUTCMonth();
            fixDate = new Date(startDay * dayFactor);

            if (fixDate.getUTCMonth() != testMonth) lastMonth = testMonth;
        }

        fixDate = new Date(weekStartIndex * dayFactor);

        if (fixDate.getUTCDay() != 0) weekStartIndex = weekStartIndex - fixDate.getUTCDay();

        // Note: rather than checking for day == 1 to switch months
        //       we check for change, this allows us to capture a
        //       first partial month

        for (var idx = startDay; idx <= endDay; ++idx) {

            var date = new Date(idx * dayFactor);

            var year = date.getUTCFullYear(); // four digit year
            var month = date.getUTCMonth() + 1; // month 0-11 adjusted
            var quarter = Math.floor((month - 1) / 3) + 1; // quarters 1-4
            var day = date.getUTCDate(); // day 1-31
            var doW = date.getUTCDay(); // day of week, 0-6

            if (year != lastYear) {

                var units = daysInYear(year);

                // check is start is before startDay
                if (!(month == 1 && day == 1)) {
                    var endOfYear = Math.floor(new Date(year + 1, 0, 0) / dayFactor);
                    units = endOfYear - idx + 1;
                }

                if (idx + units > endDay) {
                    units = endDay - idx + 1;
                    if (units < 31) {
                        units = 31;
                        adjustedEndDay = idx + 31;
                    }
                }

                _this2.years.push({
                    year: year,
                    units: units,
                    idx: idx
                });
                lastYear = year;
            }

            if (quarter != lastQuarter) {

                var startOfQuarterMonth = Math.floor((month - 1) / 3);
                var quarterStartIdx = Math.floor(new Date(year, startOfQuarterMonth * 3, 0).getTime() / dayFactor);
                var quarterEndIdx = Math.floor(new Date(year, startOfQuarterMonth * 3 + 3, 0).getTime() / dayFactor);

                var _units = quarterEndIdx - quarterStartIdx;

                if (quarterStartIdx < startDay) _units = quarterEndIdx - idx + 1;

                if (quarterEndIdx > endDay) {
                    _units = endDay - idx + 1;
                    if (_units < 31) {
                        _units = 31;
                        adjustedEndDay = idx + 31;
                    }
                }

                _this2.quarters.push({
                    quarter: quarter,
                    year: year,
                    idx: idx,
                    units: _units
                });
                lastQuarter = quarter;
            }

            if (month != lastMonth) {

                // days in month - month has been adjusted to a 1 index, which is why this works
                var _units2 = new Date(year, month, 0).getDate();

                if (day != 1) _units2 = _units2 - day + 1;

                _this2.months.push({
                    month: month,
                    year: year,
                    idx: idx,
                    units: _units2
                });

                if (idx + _units2 > endDay) adjustedEndDay = idx + _units2;

                lastMonth = month;
            }

            if (doW == 1 && idx >= weekStartIndex) _this2.weeks.push({
                day: day,
                month: month,
                year: year,
                units: 7,
                idx: idx
            });

            if (idx >= originalStartIndex) _this2.days.push({
                day: day,
                month: month,
                year: year,
                idx: idx,
                units: 1
            });
        }

        var span = adjustedEndDay - startDay + 1;

        var newState = {
            startDay: startDay,
            originalStartIndex: originalStartIndex,
            endDay: endDay,
            adjustedEndDay: adjustedEndDay,
            span: span,
            width: (span - 1) * (_this2.state.unitWidth + _this2.state.spacing),
            leftMargin: 0
        };

        if (_this2.loadStartDate && _this2.loadStartMode) {
            newState.selectedMode = _this2.loadStartMode;
            newState.selectedIndex = _this2.loadStartDate - originalStartIndex;

            setTimeout(function () {
                _this2.scrollRef.current.pan(newState.selectedIndex * (_this2.state.unitWidth + _this2.state.spacing) - 200);
            }, 100);
        }

        _this2.setState(newState);
    };

    this.makeDays = function (y) {

        var result = [];

        _this2.days.forEach(function (item, index) {
            var idx = item.idx - _this2.state.startDay;
            var x = idx * (_this2.state.unitWidth + _this2.state.spacing);

            var endIdx = _this2.props.ranges && _this2.state.selectedEndIndex != -1 ? _this2.state.selectedEndIndex : _this2.state.selectedIndex;

            var classes = ClassNames({
                'vc-cell': true,
                'click': !_this2.state.noSelect.days && !(_this2.state.selectedMode == 'day' && index >= _this2.state.selectedIndex && index <= endIdx),
                'lit': _this2.state.selectedMode == 'day' && index >= _this2.state.selectedIndex && index <= endIdx,
                'dim': _this2.state.noSelect.days
            });

            //onClick={()=>{if (!this.state.noSelect.days) this.onDayClick(index)}}

            result.push(React.createElement(
                'div',
                {
                    key: 'd_' + index,
                    className: classes,
                    onClick: function onClick() {
                        if (!_this2.state.noSelect.days) _this2.onDayClick(index);
                    },
                    style: {
                        top: y,
                        left: x
                    } },
                React.createElement(
                    'div',
                    { style: {
                            zIndex: 10
                        } },
                    item.day
                )
            ));
        });

        return result;
    };

    this.makeMonths = function (y) {

        var result = [];

        _this2.months.forEach(function (item, index) {
            var idx = item.idx - _this2.state.startDay;
            var x = idx * (_this2.state.unitWidth + _this2.state.spacing);

            var classes = ClassNames({
                'vc-cell': true,
                'click': !_this2.state.noSelect.months && !(_this2.state.selectedMode == 'month' && _this2.state.selectedIndex == index),
                'lit': _this2.state.selectedMode == 'month' && _this2.state.selectedIndex == index,
                'dim': _this2.state.noSelect.months
            });

            result.push(React.createElement(
                'div',
                {
                    key: 'm_' + index,
                    className: classes,
                    onClick: function onClick() {
                        if (!_this2.state.noSelect.months) _this2.onMonthClick(index);
                    },
                    style: {
                        top: y,
                        left: x,
                        width: item.units * (_this2.state.unitWidth + _this2.state.spacing) - 1
                    } },
                React.createElement(
                    'div',
                    { className: 'vc-cell-stay-in-view' },
                    _this2.props.showing && !_this2.props.showing.years ? monthNames[item.month - 1] + ' ' + item.year : '' + monthNames[item.month - 1]
                )
            ));
        });

        return result;
    };

    this.makeYears = function (y) {

        var result = [];

        _this2.years.forEach(function (item, index) {
            var idx = item.idx - _this2.state.startDay;
            var x = idx * (_this2.state.unitWidth + _this2.state.spacing);

            var classes = ClassNames({
                'vc-cell': true,
                'click': !_this2.state.noSelect.years && !(_this2.state.selectedMode == 'year' && _this2.state.selectedIndex == index),
                'lit': _this2.state.selectedMode == 'year' && _this2.state.selectedIndex == index,
                'dim': _this2.state.noSelect.years
            });

            result.push(React.createElement(
                'div',
                {
                    key: 'y_' + index,
                    onClick: function onClick() {
                        if (!_this2.state.noSelect.years) _this2.onYearClick(index);
                    },
                    className: classes,
                    style: {
                        top: y,
                        left: x,
                        width: item.units * (_this2.state.unitWidth + _this2.state.spacing) - 1
                    } },
                React.createElement(
                    'div',
                    { className: 'vc-cell-stay-in-view' },
                    item.year
                )
            ));
        });

        return result;
    };

    this.makeQuarters = function (y) {

        var result = [];

        _this2.quarters.forEach(function (item, index) {
            var idx = item.idx - _this2.state.startDay;
            var x = idx * (_this2.state.unitWidth + _this2.state.spacing);

            var classes = ClassNames({
                'vc-cell': true,
                'click': !_this2.state.noSelect.quarters && !(_this2.state.selectedMode == 'quarter' && _this2.state.selectedIndex == index),
                'lit': _this2.state.selectedMode == 'quarter' && _this2.state.selectedIndex == index,
                'dim': _this2.state.noSelect.quarters
            });

            result.push(React.createElement(
                'div',
                {
                    key: 'q_' + index,
                    onClick: function onClick() {
                        if (!_this2.state.noSelect.quarters) _this2.onQuarterClick(index);
                    },
                    className: classes,
                    style: {
                        top: y,
                        left: x,
                        width: item.units * (_this2.state.unitWidth + _this2.state.spacing) - 1
                    } },
                React.createElement(
                    'div',
                    { className: 'vc-cell-stay-in-view' },
                    'Q',
                    item.quarter
                )
            ));
        });

        return result;
    };

    this.makeWeeks = function (y) {

        var result = [];

        _this2.weeks.forEach(function (item, index) {
            var idx = item.idx - _this2.state.startDay;
            var x = idx * (_this2.state.unitWidth + _this2.state.spacing);
            var width = 7 * (_this2.state.unitWidth + _this2.state.spacing) - 1;

            var classes = ClassNames({
                'vc-cell': true,
                'click': !_this2.state.noSelect.weeks && !(_this2.state.selectedMode == 'week' && _this2.state.selectedIndex == index),
                'lit week': _this2.state.selectedMode == 'week' && _this2.state.selectedIndex == index,
                'dim': _this2.state.noSelect.weeks
            });

            result.push(React.createElement('div', {
                key: 'w_' + index,
                onClick: function onClick() {
                    if (!_this2.state.noSelect.weeks) _this2.onWeekClick(index);
                },
                className: classes,
                style: {
                    top: y,
                    left: x,
                    width: width,
                    height: 10,
                    borderBottomLeftRadius: 3,
                    borderBottomRightRadius: 3
                } }));
        });

        /*
                    <div className="vc-cell-stay-in-view">
                    Week of {monthShortNames[item.month-1]} {stndth(item.day)}
                    </div>
        */

        return result;
    };

    this.setEndIndex = function (mode, index) {

        if (!_this2.props.ranges || _this2.state.selectedMode != mode) {
            _this2.setState({
                selectedMode: mode,
                selectedIndex: index,
                selectedEndIndex: -1
            });
            return;
        }

        if (mode == 'day' && _this2.props.unselect && (_this2.state.selectedEndIndex == index || _this2.state.selectedEndIndex == -1) && _this2.state.selectedIndex == index) {
            _this2.setState({
                selectedMode: 'none'
            });
            return;
        } else if (mode != 'day' && _this2.props.unselect && _this2.state.selectedIndex == index) {
            _this2.setState({
                selectedMode: 'none'
            });
            return;
        }

        if (_this2.state.selectedEndIndex == -1) {
            var startIndex = _this2.state.selectedIndex;
            var endIndex = index;

            if (endIndex < startIndex) {

                var _ref2 = [startIndex, endIndex];
                endIndex = _ref2[0];
                startIndex = _ref2[1];
            }_this2.setState({
                selectedMode: mode,
                selectedIndex: startIndex,
                selectedEndIndex: endIndex
            });
            return;
        }

        var mid = (_this2.state.selectedEndIndex + _this2.state.selectedIndex) / 2;

        if (index == _this2.state.selectedEndIndex) _this2.setState({
            selectedIndex: index
        });else if (index == _this2.state.selectedIndex) _this2.setState({
            selectedEndIndex: index
        });else if (index < mid) _this2.setState({
            selectedIndex: index
        });else _this2.setState({
            selectedEndIndex: index
        });
    };

    this.onDayClick = function (index) {
        _this2.setEndIndex('day', index);
    };

    this.onWeekClick = function (index) {
        _this2.setEndIndex('week', index);
    };

    this.onMonthClick = function (index) {
        _this2.setEndIndex('month', index);
    };

    this.onQuarterClick = function (index) {
        _this2.setEndIndex('quarter', index);
    };

    this.onYearClick = function (index) {
        _this2.setEndIndex('year', index);
    };

    this.showCurrent = function () {

        return;

        var result = [];

        var selected = null;

        switch (_this2.state.selectedMode) {
            case 'day':
                selected = _this2.days[_this2.state.selectedIndex];
                break;
            case 'week':
                selected = _this2.weeks[_this2.state.selectedIndex];
                break;
            case 'month':
                selected = _this2.months[_this2.state.selectedIndex];
                break;
            case 'quarter':
                selected = _this2.quarters[_this2.state.selectedIndex];
                break;
            case 'year':
                selected = _this2.years[_this2.state.selectedIndex];
                break;
        }

        if (selected) {

            var idx = selected.idx - _this2.state.startDay;
            var units = selected.units;

            if (_this2.props.ranges && _this2.state.selectedMode == 'day') units = _this2.state.selectedEndIndex - _this2.state.selectedIndex + 1;

            var left = idx * (_this2.state.unitWidth + _this2.state.spacing);
            var width = units * (_this2.state.unitWidth + _this2.state.spacing);

            result.push(React.createElement('div', {
                key: 'mask_selected',
                className: 'vc-select',
                style: {
                    top: 7,
                    left: left,
                    width: width - 3,
                    height: _this2.maskingHeight
                } }));
        }

        return result;
    };

    this.masking = function () {

        var result = [];

        var left = 0;
        var units = _this2.state.originalStartIndex - _this2.state.startDay;
        var width = units * (_this2.state.unitWidth + _this2.state.spacing);
        var height = _this2.maskingHeight;

        if (units) result.push(React.createElement('div', {
            key: 'mask_right',
            className: 'vc-void right',
            style: {
                top: 0,
                left: left,
                width: width - 2,
                height: height
            } }));

        units = _this2.state.adjustedEndDay - _this2.state.endDay;
        left = (_this2.state.endDay - _this2.state.startDay + 1) * (_this2.state.unitWidth + _this2.state.spacing);
        width = (_this2.state.adjustedEndDay - _this2.state.endDay - 1) * (_this2.state.unitWidth + _this2.state.spacing);

        if (units) result.push(React.createElement('div', {
            key: 'mask_left',
            className: 'vc-void left',
            style: {
                top: 0,
                left: left,
                width: width,
                height: height
            } }));

        return result;
    };

    this.getSelectedDateString = function () {

        var selected = null;

        switch (_this2.state.selectedMode) {
            case 'day':
                selected = _this2.days[_this2.state.selectedIndex];
                return monthNames[selected.month - 1] + ' ' + stndth(selected.day) + ', ' + selected.year;

            case 'week':
                selected = _this2.weeks[_this2.state.selectedIndex];
                return 'Week of ' + monthNames[selected.month - 1] + ' ' + stndth(selected.day) + ', ' + selected.year;

            case 'month':
                selected = _this2.months[_this2.state.selectedIndex];
                return monthNames[selected.month - 1] + ' ' + selected.year;
            case 'quarter':
                selected = _this2.quarters[_this2.state.selectedIndex];
                return stndth(selected.quarter) + ' Quarter ' + selected.year;

            case 'year':
                selected = _this2.years[_this2.state.selectedIndex];
                return 'All of ' + selected.year;

            default:
                return 'Select a date';
        }
    };

    this.onCustomRangeClick = function (ev) {

        _this2.setState({
            noSelect: {
                weeks: true,
                months: true,
                quarters: true,
                years: true
            },
            inRange: true
        });

        ev.preventDefault();
        return false;
    };

    this.onCustomRangeCancel = function (ev) {
        _this2.setState({
            noSelect: {},
            inRange: false
        });

        ev.preventDefault();
        return false;
    };

    this.status = function () {

        return;

        if (_this2.scrollRef.current && _this2.scrollRef.current.outerRef) {

            var bounds = _this2.scrollRef.current.outerRef.current.getBoundingClientRect();

            var style = {
                left: bounds.left,
                top: bounds.top + 2,
                width: bounds.width
            };

            if (_this2.state.selectedMode == 'day' && _this2.props.ranges == true) {
                //                         Select a second {this.state.selectedMode}

                return React.createElement(
                    'div',
                    {
                        key: 'vc-status-box',
                        className: 'vc-status-box',
                        style: style },
                    'Select a Second Day\xA0\xA0\xA0\xA0',
                    React.createElement(
                        'div',
                        {
                            onClick: _this2.onCustomRangeCancel,
                            className: 'vc-range-button' },
                        'Cancel'
                    )
                );
            }

            return (
                //                     {this.getSelectedDateString()}

                React.createElement(
                    'div',
                    {
                        key: 'vc-status-box',
                        className: 'vc-status-box',
                        style: style },
                    _this2.state.selectedMode == 'day' && React.createElement(
                        'div',
                        {
                            onClick: _this2.onCustomRangeClick,
                            className: 'vc-range-button' },
                        'Select Range'
                    )
                )
            );
        }
    };
};

export default HorizontalCalendar;
//# sourceMappingURL=index.es.js.map
