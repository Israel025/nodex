import React from 'react';

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".scrollomatic-outer-container\n{\n    position: relative;\n    display: block;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n\n.scrollomatic-inner-container\n{\n    position: absolute;\n    display: block;\n    top: 0;\n    left: 0;\n    z-index: 1;\n    transition: left 0s ease-out, top 0s ease-out;\n}\n\n.scrollomatic-inner-container.slow-scroll\n{\n    transition-duration: 1s;\n}\n\n.scrollomatic-bottom-rail-light \n{\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 12px;\n    left: 0;\n    bottom: 0;\n    background-color: rgba(160,160,160,0.85);\n    transition: opacity 0.5s ease;    \n    z-index: 56;\n    cursor: ew-resize;\n}\n\n.scrollomatic-bottom-rail-dark\n{\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 12px;\n    left: 0;\n    bottom: 0;\n    background-color: rgba(80,80,80,0.85);\n    transition: opacity 0.5s ease;    \n    z-index: 55;\n    cursor: ew-resize;\n}\n\n.scrollomatic-bottom-thumb-light\n{\n    pointer-events: none;\n    position: absolute;\n    display: block;\n    top: 2px;\n    left: 30px;\n    height: 8px;\n    margin-left: 0;\n    border-radius: 5px;\n    background-color:rgba(0,0,0,0.4);\n    transition: background-color 0.5s ease;\n} \n\n.scrollomatic-bottom-thumb-dark\n{\n    pointer-events: none;\n    position: absolute;\n    display: block;\n    top: 2px;\n    left: 30px;\n    height: 8px;\n    margin-left: 0;\n    border-radius: 5px;\n    background-color:rgba(255,255,255,0.4);\n    transition: background-color 0.5s ease;\n} \n\n.scrollomatic-bottom-thumb-light.scrolling {\n    background-color: rgba(0,0,0,0.6);\n}\n\n.scrollomatic-bottom-thumb-dark.scrolling {\n    background-color: rgba(255,255,255,0.7);\n}\n\n.scrollomatic-side-rail-light\n{\n    position: absolute;\n    display: block;\n    top: 0;    \n    right: 0;\n    width: 12px;\n    height: 100%;\n    background-color: rgba(160,160,160,0.85);\n    transition: opacity 0.5s ease;    \n    z-index: 56;\n    cursor: ns-resize;    \n}\n\n.scrollomatic-side-rail-dark\n{\n    position: absolute;\n    display: block;\n    top: 0;    \n    right: 0;\n    width: 12px;\n    height: 100%;\n    background-color: rgba(80,80,80,0.85);\n    transition: opacity 0.5s ease;    \n    z-index: 55;\n    cursor: ns-resize;\n}\n\n.scrollomatic-side-thumb-light\n{\n    pointer-events: none;\n    position: absolute;\n    display: block;\n    top: 20px;\n    left: 2px;\n    width: 8px;\n    margin-left: 0;\n    border-radius: 5px;\n    background-color:rgba(0,0,0,0.4);\n    transition: background-color 0.5s ease;\n} \n\n.scrollomatic-side-thumb-dark\n{\n    pointer-events: none;\n    position: absolute;\n    display: block;\n    top: 20px;\n    left: 2px;\n    width: 8px;\n    margin-left: 0;\n    border-radius: 5px;\n    background-color:rgba(255,255,255,0.4);\n    transition: background-color 0.5s ease;\n} \n\n.scrollomatic-side-thumb-light.scrolling {\n    background-color: rgba(0,0,0,0.6);\n}\n\n.scrollomatic-side-thumb-dark.scrolling {\n    background-color: rgba(255,255,255,0.7);\n}\n";
styleInject(css);

/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @providesModule UserAgent_DEPRECATED
 */

/**
 *  Provides entirely client-side User Agent and OS detection. You should prefer
 *  the non-deprecated UserAgent module when possible, which exposes our
 *  authoritative server-side PHP-based detection to the client.
 *
 *  Usage is straightforward:
 *
 *    if (UserAgent_DEPRECATED.ie()) {
 *      //  IE
 *    }
 *
 *  You can also do version checks:
 *
 *    if (UserAgent_DEPRECATED.ie() >= 7) {
 *      //  IE7 or better
 *    }
 *
 *  The browser functions will return NaN if the browser does not match, so
 *  you can also do version compares the other way:
 *
 *    if (UserAgent_DEPRECATED.ie() < 7) {
 *      //  IE6 or worse
 *    }
 *
 *  Note that the version is a float and may include a minor version number,
 *  so you should always use range operators to perform comparisons, not
 *  strict equality.
 *
 *  **Note:** You should **strongly** prefer capability detection to browser
 *  version detection where it's reasonable:
 *
 *    http://www.quirksmode.org/js/support.html
 *
 *  Further, we have a large number of mature wrapper functions and classes
 *  which abstract away many browser irregularities. Check the documentation,
 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
 *  another copy of "event || window.event".
 *
 */

var _populated = false;

// Browsers
var _ie, _firefox, _opera, _webkit, _chrome;

// Actual IE browser for compatibility mode
var _ie_real_version;

// Platforms
var _osx, _windows, _linux, _android;

// Architectures
var _win64;

// Devices
var _iphone, _ipad, _native;

var _mobile;

function _populate() {
  if (_populated) {
    return;
  }

  _populated = true;

  // To work around buggy JS libraries that can't handle multi-digit
  // version numbers, Opera 10's user agent string claims it's Opera
  // 9, then later includes a Version/X.Y field:
  //
  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);

  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas);

  // Note that the IE team blog would have you believe you should be checking
  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
  // from either x64 or ia64;  so ultimately, you should just check for Win64
  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
  // Windows will send 'WOW64' instead.
  _win64 = !!(/Win64/.exec(uas));

  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : (
          agent[5] ? parseFloat(agent[5]) : NaN);
    // IE compatibility mode
    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    }
    // grab the "true" ie version from the trident token if available
    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;

    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;
    if (_webkit) {
      // We do not add the regexp to the above test, because it will always
      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
      // the userAgent string.
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }

  if (os) {
    if (os[1]) {
      // Detect OS X version.  If no version number matches, set _osx to true.
      // Version examples:  10, 10_6_1, 10.7
      // Parses version number as a float, taking only first two sets of
      // digits.  If only one set of digits is found, returns just the major
      // version number.
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);

      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
    } else {
      _osx = false;
    }
    _windows = !!os[2];
    _linux   = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}

var UserAgent_DEPRECATED = {

  /**
   *  Check if the UA is Internet Explorer.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  ie: function() {
    return _populate() || _ie;
  },

  /**
   * Check if we're in Internet Explorer compatibility mode.
   *
   * @return bool true if in compatibility mode, false if
   * not compatibility mode or not ie
   */
  ieCompatibilityMode: function() {
    return _populate() || (_ie_real_version > _ie);
  },


  /**
   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
   * this when we don't need it -- tracked by #601957.
   */
  ie64: function() {
    return UserAgent_DEPRECATED.ie() && _win64;
  },

  /**
   *  Check if the UA is Firefox.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  firefox: function() {
    return _populate() || _firefox;
  },


  /**
   *  Check if the UA is Opera.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  opera: function() {
    return _populate() || _opera;
  },


  /**
   *  Check if the UA is WebKit.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  webkit: function() {
    return _populate() || _webkit;
  },

  /**
   *  For Push
   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
   */
  safari: function() {
    return UserAgent_DEPRECATED.webkit();
  },

  /**
   *  Check if the UA is a Chrome browser.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  chrome : function() {
    return _populate() || _chrome;
  },


  /**
   *  Check if the user is running Windows.
   *
   *  @return bool `true' if the user's OS is Windows.
   */
  windows: function() {
    return _populate() || _windows;
  },


  /**
   *  Check if the user is running Mac OS X.
   *
   *  @return float|bool   Returns a float if a version number is detected,
   *                       otherwise true/false.
   */
  osx: function() {
    return _populate() || _osx;
  },

  /**
   * Check if the user is running Linux.
   *
   * @return bool `true' if the user's OS is some flavor of Linux.
   */
  linux: function() {
    return _populate() || _linux;
  },

  /**
   * Check if the user is running on an iPhone or iPod platform.
   *
   * @return bool `true' if the user is running some flavor of the
   *    iPhone OS.
   */
  iphone: function() {
    return _populate() || _iphone;
  },

  mobile: function() {
    return _populate() || (_iphone || _ipad || _android || _mobile);
  },

  nativeApp: function() {
    // webviews inside of the native apps
    return _populate() || _native;
  },

  android: function() {
    return _populate() || _android;
  },

  ipad: function() {
    return _populate() || _ipad;
  }
};

var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED;

/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

var ExecutionEnvironment_1 = ExecutionEnvironment;

var useHasFeature;
if (ExecutionEnvironment_1.canUseDOM) {
  useHasFeature =
    document.implementation &&
    document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment_1.canUseDOM ||
      capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

var isEventSupported_1 = isEventSupported;

// Reasonable defaults
var PIXEL_STEP  = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;

/**
 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
 * complicated, thus this doc is long and (hopefully) detailed enough to answer
 * your questions.
 *
 * If you need to react to the mouse wheel in a predictable way, this code is
 * like your bestest friend. * hugs *
 *
 * As of today, there are 4 DOM event types you can listen to:
 *
 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
 *
 * So what to do?  The is the best:
 *
 *   normalizeWheel.getEventType();
 *
 * In your event callback, use this code to get sane interpretation of the
 * deltas.  This code will return an object with properties:
 *
 *   spinX   -- normalized spin speed (use for zoom) - x plane
 *   spinY   -- " - y plane
 *   pixelX  -- normalized distance (to pixels) - x plane
 *   pixelY  -- " - y plane
 *
 * Wheel values are provided by the browser assuming you are using the wheel to
 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
 * significantly on different platforms and browsers, forgetting that you can
 * scroll at different speeds.  Some devices (like trackpads) emit more events
 * at smaller increments with fine granularity, and some emit massive jumps with
 * linear speed or acceleration.
 *
 * This code does its best to normalize the deltas for you:
 *
 *   - spin is trying to normalize how far the wheel was spun (or trackpad
 *     dragged).  This is super useful for zoom support where you want to
 *     throw away the chunky scroll steps on the PC and make those equal to
 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
 *     resolve a single slow step on a wheel to 1.
 *
 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
 *     get the crazy differences between browsers, but at least it'll be in
 *     pixels!
 *
 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
 *     should translate to positive value zooming IN, negative zooming OUT.
 *     This matches the newer 'wheel' event.
 *
 * Why are there spinX, spinY (or pixels)?
 *
 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
 *     with a mouse.  It results in side-scrolling in the browser by default.
 *
 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
 *
 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
 *     probably is by browsers in conjunction with fancy 3D controllers .. but
 *     you know.
 *
 * Implementation info:
 *
 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
 * average mouse:
 *
 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
 *
 * On the trackpad:
 *
 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
 *
 * On other/older browsers.. it's more complicated as there can be multiple and
 * also missing delta values.
 *
 * The 'wheel' event is more standard:
 *
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
 *
 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
 * backward compatibility with older events.  Those other values help us
 * better normalize spin speed.  Example of what the browsers provide:
 *
 *                          | event.wheelDelta | event.detail
 *        ------------------+------------------+--------------
 *          Safari v5/OS X  |       -120       |       0
 *          Safari v5/Win7  |       -120       |       0
 *         Chrome v17/OS X  |       -120       |       0
 *         Chrome v17/Win7  |       -120       |       0
 *                IE9/Win7  |       -120       |   undefined
 *         Firefox v4/OS X  |     undefined    |       1
 *         Firefox v4/Win7  |     undefined    |       3
 *
 */
function normalizeWheel(/*object*/ event) /*object*/ {
  var sX = 0, sY = 0,       // spinX, spinY
      pX = 0, pY = 0;       // pixelX, pixelY

  // Legacy
  if ('detail'      in event) { sY = event.detail; }
  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

  // side scrolling on FF with DOMMouseScroll
  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in event) { pY = event.deltaY; }
  if ('deltaX' in event) { pX = event.deltaX; }

  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {          // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {                             // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

  return { spinX  : sX,
           spinY  : sY,
           pixelX : pX,
           pixelY : pY };
}


/**
 * The best combination if you prefer spinX + spinY normalization.  It favors
 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
 * 'wheel' event, making spin speed determination impossible.
 */
normalizeWheel.getEventType = function() /*string*/ {
  return (UserAgent_DEPRECATED_1.firefox())
           ? 'DOMMouseScroll'
           : (isEventSupported_1('wheel'))
               ? 'wheel'
               : 'mousewheel';
};

var normalizeWheel_1 = normalizeWheel;

var normalizeWheel$1 = normalizeWheel_1;

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var idCounter = 1;

var BottomScroller = function (_React$Component) {
    inherits(BottomScroller, _React$Component);

    function BottomScroller(props) {
        classCallCheck(this, BottomScroller);

        var _this = possibleConstructorReturn(this, (BottomScroller.__proto__ || Object.getPrototypeOf(BottomScroller)).call(this, props));

        _this.calculate = function () {
            var showingRatio = _this.props.windowSize / _this.props.scrollSize;
            _this.thumbSize = _this.props.windowSize * showingRatio;
        };

        _this.onOnePage = function (ev) {
            var onePage = _this.props.windowSize * 0.5;

            var ratio = _this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize);
            // get actual postion in scroll range and add the normalized pixel change
            // we increment (by delta) the number of pixels of scroll, not the scroll bar position which is choppy
            // and doesn't scale on really long lists
            var actualPosition = ratio * (_this.props.scrollSize - _this.props.windowSize) + (_this.state.inBox == 'left' ? -1 * onePage : onePage);

            var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

            if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: newPosition,
                clickScroll: true
            });
            _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize), true);

            ev.preventDefault();
            ev.stopPropagation();
        };

        _this.scrollTo = function (position, scrollEffect) {

            scrollEffect = scrollEffect === true;
            var actualPosition = position;

            var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

            if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: newPosition,
                clickScroll: true
            });
            _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize), scrollEffect);
        };

        _this.onMouseDown = function (ev) {

            var railBounds = _this.railRef.current.getBoundingClientRect();

            if (_this.state.inBox !== true) {
                _this.onOnePage(ev);
                return;
            }

            _this.setState({
                mouseDown: true,
                clickScroll: false
            });

            _this.startPosition = _this.state.thumbPosition - (ev.clientX - railBounds.left); //- this.thumbRef.current.getBoundingClientRect().left - railBounds.left

            document.addEventListener('mouseup', _this.onMouseUp, true);
            document.addEventListener('mousemove', _this.onMouseMove, true);
            ev.preventDefault();
            ev.stopPropagation();

            document.body.style['pointer-events'] = 'none';
        };

        _this.setPosition = function (ev) {
            var railBounds = _this.railRef.current.getBoundingClientRect();

            var thumbPosition = ev.clientX - railBounds.left + _this.startPosition;

            if (thumbPosition < 0) thumbPosition = 0;else if (thumbPosition + _this.thumbSize > _this.props.windowSize) thumbPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: thumbPosition
            });
        };

        _this.onTarget = function (ev) {
            var railBounds = _this.railRef.current.getBoundingClientRect();
            var left = ev.clientX - railBounds.left;

            _this.setState({
                inBox: left >= _this.state.thumbPosition && left <= _this.state.thumbPosition + _this.thumbSize ? true : left < _this.state.thumbPosition ? 'left' : 'right'
            });
        };

        _this.onMouseUp = function (ev) {

            if (_this.state.mouseDown) {
                _this.setState({
                    mouseDown: false
                });
            }

            if (_this.state.clickScroll) {
                _this.setState({
                    clickScroll: false
                });

                ev.stopPropagation();
                ev.preventDefault();
                return;
            }

            var railBounds = _this.railRef.current.getBoundingClientRect();

            if (ev.clientX >= railBounds.left && ev.clientX <= railBounds.right && ev.clientY >= railBounds.top && ev.clientY <= railBounds.bottom) ; else {
                _this.setState({
                    showing: false
                });
            }

            document.removeEventListener('mouseup', _this.onMouseUp, true);
            document.removeEventListener('mousemove', _this.onMouseMove, true);
            ev.stopPropagation();
            ev.preventDefault();

            document.body.style['pointer-events'] = 'auto';
        };

        _this.onMouseMove = function (ev) {

            ev.stopPropagation();
            ev.preventDefault();

            _this.onTarget(ev);

            if (!_this.state.mouseDown) return false;

            _this.setPosition(ev);

            if (_this.props.onPan) _this.props.onPan(_this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize));

            return true;
        };

        _this.onMouseEnter = function (ev) {
            _this.setState({
                showing: true
            });
        };

        _this.onMouseLeave = function (ev) {
            if (!_this.state.mouseDown) _this.setState({
                showing: false
            });
        };

        _this.onWheel = function (ev) {

            // call fancy facebook function that un-messes all the browser variations with
            // wheel scroll deltas (thank you FB)
            var normalized = normalizeWheel$1(ev);

            if (!_this.inWheel) {
                _this.inWheel = true;
            }

            if (normalized.pixelX) {

                // get the percentage along of scroll position to scroll area (width - with of thumb)
                var ratio = _this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize);
                // get actual postion in scroll range and add the normalized pixel change
                // we increment (by delta) the number of pixels of scroll, not the scroll bar position which is choppy
                // and doesn't scale on really long lists
                var actualPosition = ratio * (_this.props.scrollSize - _this.props.windowSize) + normalized.pixelX;

                // convert this back to scroll pixels..
                var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

                if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

                _this.setState({
                    thumbPosition: newPosition,
                    showing: normalized.pixelX ? true : false
                });
                _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize));
            }

            if (_this.scrollHideTo) clearTimeout(_this.scrollHideTo);

            _this.scrollHideTo = setTimeout(function () {
                _this.scrollHideTo = null;
                _this.setState({
                    showing: false,
                    mouseDown: false,
                    inBox: false
                });
                _this.inWheel = false;
            }, 500);

            ev.preventDefault();
        };

        _this.state = {
            thumbPosition: 0,
            startPosition: 0,
            id: ++idCounter + '_h_scroller',
            clickStarted: false
        };

        _this.railRef = React.createRef();
        _this.thumbRef = React.createRef();
        return _this;
    }

    createClass(BottomScroller, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.calculate();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            this.calculate();
        }
    }, {
        key: 'render',
        value: function render() {

            var thumbClass = this.props.dark ? 'scrollomatic-bottom-thumb-dark' : 'scrollomatic-bottom-thumb-light';

            if (this.state.mouseDown || this.state.inBox === true) thumbClass += ' scrolling';

            return React.createElement(
                'div',
                {
                    id: this.state.id,
                    ref: this.railRef,
                    className: this.props.dark ? 'scrollomatic-bottom-rail-dark' : 'scrollomatic-bottom-rail-light',
                    onMouseDown: this.onMouseDown,
                    onMouseEnter: this.onMouseEnter,
                    onMouseLeave: this.onMouseLeave,
                    onMouseMove: this.onMouseMove,
                    onWheel: this.onWheel,
                    style: {
                        width: this.props.windowSize,
                        opacity: this.state.showing ? 1 : 0.001
                    }
                },
                React.createElement('div', {
                    ref: this.thumbRef,
                    className: thumbClass,
                    style: {
                        left: this.state.thumbPosition,
                        width: this.thumbSize
                    } })
            );
        }
    }]);
    return BottomScroller;
}(React.Component);

var idCounter$1 = 1;

var SideScroller = function (_React$Component) {
    inherits(SideScroller, _React$Component);

    function SideScroller(props) {
        classCallCheck(this, SideScroller);

        var _this = possibleConstructorReturn(this, (SideScroller.__proto__ || Object.getPrototypeOf(SideScroller)).call(this, props));

        _this.calculate = function () {

            var scrollSize = _this.props.windowSize < _this.props.scrollSize ? _this.props.scrollSize : _this.props.windowSize;

            var showingRatio = _this.props.windowSize / scrollSize;
            _this.thumbSize = _this.props.windowSize * showingRatio;
        };

        _this.onOnePage = function (ev) {

            var onePage = _this.props.windowSize * 0.5;

            var ratio = _this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize);
            // get actual postion in scroll range and add the normalized pixel change
            // we increment (by delta) the number of pixels of scroll, not the scroll bar position which is choppy
            // and doesn't scale on really long lists
            var actualPosition = ratio * (_this.props.scrollSize - _this.props.windowSize) + (_this.state.inBox == 'left' ? -1 * onePage : onePage);

            var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

            if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: newPosition,
                clickScroll: true
            });
            _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize), true);

            ev.preventDefault();
            ev.stopPropagation();
        };

        _this.scrollTo = function (position, scrollEffect) {

            scrollEffect = scrollEffect === true;
            var actualPosition = position;

            var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

            if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: newPosition,
                clickScroll: true
            });
            _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize), scrollEffect);
        };

        _this.onMouseDown = function (ev) {

            var railBounds = _this.railRef.current.getBoundingClientRect();

            if (_this.state.inBox !== true) {
                _this.onOnePage(ev);
                return;
            }

            _this.setState({
                mouseDown: true,
                clickScroll: false
            });

            _this.startPosition = _this.state.thumbPosition - (ev.clientY - railBounds.top); //- this.thumbRef.current.getBoundingClientRect().left - railBounds.left

            document.addEventListener('mouseup', _this.onMouseUp, true);
            document.addEventListener('mousemove', _this.onMouseMove, true);
            ev.preventDefault();
            ev.stopPropagation();

            document.body.style['pointer-events'] = 'none';
        };

        _this.setPosition = function (ev) {
            var railBounds = _this.railRef.current.getBoundingClientRect();

            var thumbPosition = ev.clientY - railBounds.top + _this.startPosition;

            if (thumbPosition < 0) thumbPosition = 0;else if (thumbPosition + _this.thumbSize > _this.props.windowSize) thumbPosition = _this.props.windowSize - _this.thumbSize;

            _this.setState({
                thumbPosition: thumbPosition
            });
        };

        _this.onTarget = function (ev) {
            var railBounds = _this.railRef.current.getBoundingClientRect();
            var left = ev.clientY - railBounds.top;

            _this.setState({
                inBox: left >= _this.state.thumbPosition && left <= _this.state.thumbPosition + _this.thumbSize ? true : left < _this.state.thumbPosition ? 'left' : 'right'
            });
        };

        _this.onMouseUp = function (ev) {

            if (_this.state.mouseDown) {
                _this.setState({
                    mouseDown: false
                });
            }

            if (_this.state.clickScroll) {
                _this.setState({
                    clickScroll: false
                });

                ev.stopPropagation();
                ev.preventDefault();
                return;
            }

            var railBounds = _this.railRef.current.getBoundingClientRect();

            if (ev.clientX >= railBounds.left && ev.clientX <= railBounds.right && ev.clientY >= railBounds.top && ev.clientY <= railBounds.bottom) ; else {
                _this.setState({
                    showing: false
                });
            }

            document.removeEventListener('mouseup', _this.onMouseUp, true);
            document.removeEventListener('mousemove', _this.onMouseMove, true);
            ev.stopPropagation();
            ev.preventDefault();

            document.body.style['pointer-events'] = 'auto';
        };

        _this.onMouseMove = function (ev) {

            ev.stopPropagation();
            ev.preventDefault();

            _this.onTarget(ev);

            if (!_this.state.mouseDown) return false;

            _this.setPosition(ev);

            if (_this.props.onPan) _this.props.onPan(_this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize));

            return true;
        };

        _this.onMouseEnter = function (ev) {
            _this.setState({
                showing: true
            });
        };

        _this.onMouseLeave = function (ev) {
            if (!_this.state.mouseDown) _this.setState({
                showing: false
            });
        };

        _this.onWheel = function (ev) {

            // call fancy facebook function that un-messes all the browser variations with
            // wheel scroll deltas (thank you FB)
            var normalized = normalizeWheel$1(ev);

            if (!_this.inWheel) {
                _this.inWheel = true;
            }

            if (normalized.pixelY) {

                // get the percentage along of scroll position to scroll area (width - with of thumb)
                var ratio = _this.state.thumbPosition / (_this.props.windowSize - _this.thumbSize);
                // get actual postion in scroll range and add the normalized pixel change
                // we increment (by delta) the number of pixels of scroll, not the scroll bar position which is choppy
                // and doesn't scale on really long lists
                var actualPosition = ratio * (_this.props.scrollSize - _this.props.windowSize) + normalized.pixelY;

                // convert this back to scroll pixels..
                var newPosition = actualPosition / (_this.props.scrollSize - _this.props.windowSize) * (_this.props.windowSize - _this.thumbSize);

                if (newPosition < 0) newPosition = 0;else if (newPosition + _this.thumbSize > _this.props.windowSize) newPosition = _this.props.windowSize - _this.thumbSize;

                _this.setState({
                    thumbPosition: newPosition,
                    showing: normalized.pixelY ? true : false
                });
                _this.props.onPan(newPosition / (_this.props.windowSize - _this.thumbSize));
            }

            if (_this.scrollHideTo) clearTimeout(_this.scrollHideTo);

            _this.scrollHideTo = setTimeout(function () {
                _this.scrollHideTo = null;
                _this.setState({
                    showing: false,
                    mouseDown: false,
                    inBox: false
                });
                _this.inWheel = false;
            }, 500);

            ev.preventDefault();
        };

        _this.state = {
            thumbPosition: 0,
            startPosition: 0,
            id: ++idCounter$1 + '_v_scroller',
            clickStarted: false
        };

        _this.railRef = React.createRef();
        _this.thumbRef = React.createRef();
        return _this;
    }

    createClass(SideScroller, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.calculate();
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            this.calculate();
        }
    }, {
        key: 'render',
        value: function render() {

            var thumbClass = this.props.dark ? 'scrollomatic-side-thumb-dark' : 'scrollomatic-side-thumb-light';

            if (this.state.mouseDown || this.state.inBox === true) thumbClass += ' scrolling';

            return React.createElement(
                'div',
                {
                    id: this.state.id,
                    ref: this.railRef,
                    className: this.props.dark ? 'scrollomatic-side-rail-dark' : 'scrollomatic-side-rail-light',
                    onMouseDown: this.onMouseDown,
                    onMouseEnter: this.onMouseEnter,
                    onMouseLeave: this.onMouseLeave,
                    onMouseMove: this.onMouseMove,
                    onWheel: this.onWheel,
                    style: {
                        height: this.props.windowSize,
                        opacity: this.state.showing ? 1 : 0.001
                    }
                },
                React.createElement('div', {
                    ref: this.thumbRef,
                    className: thumbClass,
                    style: {
                        top: this.state.thumbPosition,
                        height: this.thumbSize
                    } })
            );
        }
    }]);
    return SideScroller;
}(React.Component);

var Scrollomatic = function (_React$Component) {
    inherits(Scrollomatic, _React$Component);

    function Scrollomatic(props) {
        classCallCheck(this, Scrollomatic);

        var _this = possibleConstructorReturn(this, (Scrollomatic.__proto__ || Object.getPrototypeOf(Scrollomatic)).call(this, props));

        _this.getDims = function () {
            var bounds = _this.outerRef.current.getBoundingClientRect();

            var newState = {
                windowWidth: bounds.width,
                windowHeight: bounds.height,

                scrollWidth: _this.innerRef.current.scrollWidth,
                scrollHeight: _this.innerRef.current.scrollHeight
            };

            _this.setState(_extends({}, newState, {
                dims: true,
                showHorz: newState.scrollWidth > newState.windowWidth && !_this.props.noHorizontal ? true : false,
                showVert: newState.scrollHeight > newState.windowHeight && !_this.props.noVertical ? true : false
            }));
        };

        _this.onWheel = function (ev) {
            if (_this.state.showHorz) _this.horzRef.current.onWheel(ev);
            if (_this.state.showVert) _this.vertRef.current.onWheel(ev);

            ev.stopPropagation();
            if (ev.preventDefault) ev.preventDefault();
        };

        _this.onHScroll = function (ratio, isPage) {
            _this.setState({
                hpos: -1 * (ratio * (_this.state.scrollWidth - _this.state.windowWidth)),
                onePage: isPage
            });

            if (_this.unsetTo) clearTimeout(_this.unsetTo);

            if (isPage) {
                _this.unsetTo = setTimeout(function () {
                    _this.unsetTo = null;
                    _this.setState({
                        onePage: false
                    });
                }, 1100);
            }
        };

        _this.onVScroll = function (ratio, isPage) {
            _this.setState({
                vpos: -1 * (ratio * (_this.state.scrollHeight - _this.state.windowHeight)),
                onePage: isPage
            });

            if (_this.unsetTo) clearTimeout(_this.unsetTo);

            if (isPage) {

                _this.unsetTo = setTimeout(function () {
                    _this.unsetTo = null;
                    _this.setState({
                        onePage: false
                    });
                }, 1100);
            }
        };

        _this.pan = function (left, top) {
            if (left && _this.state.showHorz) _this.horzRef.current.scrollTo(left);
            if (top && _this.state.showVert) _this.vertRef.current.scrollTo(top);
        };

        _this.state = {
            vPos: 0,
            hPos: 0
        };

        _this.outerRef = React.createRef();
        _this.innerRef = React.createRef();

        _this.horzRef = React.createRef();
        _this.vertRef = React.createRef();

        _this.dimCheckInterval = null;
        return _this;
    }

    createClass(Scrollomatic, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.dimCheckInterval = setInterval(this.getDims, 100);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            clearInterval(this.dimCheckInterval);
        }
    }, {
        key: 'render',
        value: function render() {

            var innerClasses = 'scrollomatic-inner-container';

            if (this.state.onePage) innerClasses += ' slow-scroll';

            return React.createElement(
                'div',
                {
                    ref: this.outerRef,
                    style: _extends({}, this.props.style),
                    className: 'scrollomatic-outer-container' },
                React.createElement(
                    'div',
                    {
                        ref: this.innerRef,
                        className: innerClasses,
                        onWheel: this.onWheel,
                        style: {
                            left: this.state.hpos,
                            top: this.state.vpos
                        }
                    },
                    this.props.children
                ),
                this.state.showHorz && React.createElement(BottomScroller, {
                    ref: this.horzRef,
                    dark: this.props.dark,
                    scrollSize: this.state.scrollWidth,
                    windowSize: this.state.windowWidth,
                    corner: this.state.showHorz && this.state.showVert,
                    onPan: this.onHScroll }),
                this.state.showVert && React.createElement(SideScroller, {
                    ref: this.vertRef,
                    dark: this.props.dark,
                    scrollSize: this.state.scrollHeight,
                    windowSize: this.state.windowHeight,
                    corner: this.state.showHorz && this.state.showVert,
                    onPan: this.onVScroll })
            );
        }
    }]);
    return Scrollomatic;
}(React.Component);

export default Scrollomatic;
//# sourceMappingURL=index.es.js.map
